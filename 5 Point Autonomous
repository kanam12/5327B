#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           RRoller,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LTLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LBLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           RBLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RTLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RBBase,        tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port7,           RFBase,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LBBase,        tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port9,           LFBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LRoller,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Sensor, dgtl9,  PistonL,        sensorDigitalOut)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
void reset()
{
	nMotorEncoder[RBBase] = 0;
	nMotorEncoder[LBBase] = 0;
}


task main()
{
	while(true){
		if(vexRT[Btn8U] == 1){
			reset();
			//while(nMotorEncoder[LBBase] > -110 && vexRT[Btn8D] == 0)
			//{ //Wiring was working as of 11/4, adding second IME
			motor[RBBase] = 60;
			motor[LFBase] = 60;
			motor[RFBase] = 60;
			motor[LBBase] = 60;
			//}
			wait1Msec(700);
			motor[RBBase] = 0;
			motor[LFBase] = 0;
			motor[RFBase] = 0;
			motor[LBBase] = 0;

			motor[LRoller] = 100;
			motor[LRoller] = 100;
			wait1Msec(1200);
			motor[RRoller] = 0;
			motor[LRoller] = 0;


			motor[RBBase] = -60;
			motor[LFBase] = -60;
			motor[RFBase] = -60;
			motor[LBBase] = -60;
			//}
			wait1Msec(500);
			motor[RBBase] = 0;
			motor[LFBase] = 0;
			motor[RFBase] = 0;
			motor[LBBase] = 0;

			motor[LTLift] = 80;
			motor[RTLift] = 80;
			motor[LBLift] = 80;
			motor[RBLift] = 80;
			while(SensorValue[pot] < 3450)
			{
			}
			motor[LTLift] = 0;
			motor[RTLift] = 0;
			motor[LBLift] = 0;
			motor[RBLift] = 0;
			wait1Msec(500);
			SensorValue[PistonL] = 1;




			motor[RBBase] = 50;
			motor[LFBase] = -50;
			motor[RFBase] = 50;
			motor[LBBase] = -50;
			//}
			wait1Msec(1250);
			motor[RBBase] = 0;
			motor[LFBase] = 0;
			motor[RFBase] = 0;
			motor[LBBase] = 0;

			wait1Msec(250);

			motor[RBBase] = -50;
			motor[LFBase] = -50;
			motor[RFBase] = -50;
			motor[LBBase] = -50;
			//}
			wait1Msec(5500);
			motor[RBBase] = 0;
			motor[LFBase] = 0;
			motor[RFBase] = 0;
			motor[LBBase] = 0;


			motor[RRoller] = -127;
			motor[LRoller] = -127;
			wait1Msec(2000);
			motor[RRoller] = 0;
			motor[LRoller] = 0;

			//AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
		}
	}



}
