

#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    RPot,           sensorPotentiometer)
#pragma config(Sensor, in2,    LPot,           sensorPotentiometer)
#pragma config(Sensor, in3,    Gyro,           sensorGyro)
#pragma config(Sensor, in4,    RLine,          sensorLineFollower)
#pragma config(Sensor, in5,    LLine,          sensorLineFollower)
#pragma config(Sensor, dgtl2,  Skyrise,        sensorDigitalOut)
#pragma config(Sensor, dgtl3,  Dump,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  RFBase,         sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  LFBase,         sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           RRoller,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RBLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RTLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LBLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LTLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RBBase,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RFBase,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port8,           LBBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LFBase,        tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          LRoller,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////............................PRE_AUTON
//                          Pre-Autonomous Functions
void pre_auton()
{
	//bStopTasksBetweenModes = true;
	SensorType[in3] = sensorNone;
	wait1Msec(1000);
	SensorType[in3] = sensorGyro;
	wait1Msec(2000);

}
//
/////////////////////////////////////////////////////////////////////////////////////////

bool triggered = false;

bool slowActivate = true;

const int slowSpeed = 40;

const int upSlow = 10;

const unsigned int TrueSpeed[128] =
{
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0, 21, 21, 21, 22, 22, 22, 23, 24, 24,
	25, 25, 25, 25, 26, 27, 27, 28, 28, 28,
	28, 29, 30, 30, 30, 31, 31, 32, 32, 32,
	33, 33, 34, 34, 35, 35, 35, 36, 36, 37,
	37, 37, 37, 38, 38, 39, 39, 39, 40, 40,
	41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
	46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
	52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
	61, 62, 63, 64, 65, 66, 67, 67, 68, 70,
	71, 72, 72, 73, 74, 76, 77, 78, 79, 79,
	80, 81, 83, 84, 84, 86, 86, 87, 87, 88,
	88, 89, 89, 90, 90,127,127,127
};

int rPoten()
{
	int const adjVal = 315;
	return (SensorValue[RPot] - adjVal)  * 4095 / 3632;
}
int map(int min1, int max1, int min2, int max2, int num)
{
	return num / (max2 - min2) * (max1 - min1) + min2;
}

int lPoten()
{
	int const adjVal = 365;
	return map(0, 4095, adjVal, 3012, (SensorValue[LPot] - adjVal));
}


//////LIFT/////..................................................................................................TOP_Functions
void lift(int state)
{
	//Normal lift operation
	if(state < 0 && lPoten() > 10)
	{
		motor[LBLift] = state * slowSpeed;
		motor[LTLift] = state * slowSpeed;
		motor[RBLift] = state * slowSpeed;
		motor[RTLift] = state * slowSpeed;
	}
	else if(state > 0)
	{
		motor[LBLift] = state * 100;
		motor[LTLift] = state * 100;
		motor[RBLift] = state * 100;
		motor[RTLift] = state * 100;
	}
	else
	{
		motor[LBLift] = upSlow * slowActivate;
		motor[LTLift] = upSlow * slowActivate;
		motor[RBLift] = upSlow * slowActivate;
		motor[RTLift] = upSlow * slowActivate;
	}

	//Manual lift adjustment

	if(vexRT[Btn7U] == 1)
	{
		motor[LBLift] = 85;
		motor[LTLift] = 85;
	}
	else if(vexRT[Btn7D] == 1)
	{
		motor[LBLift] = -85;
		motor[LTLift] = -85;
	}
	else if(vexRT[Btn8U] == 1)
	{
		motor[RBLift] = 85;
		motor[RTLift] = 85;
	}
	else if(vexRT[Btn8D] == 1)
	{
		motor[RBLift] = -85;
		motor[RTLift] = -85;
	}

	//Automatic lift adjustment
	if(lPoten() > rPoten() && state == 1)
	{
		motor[LBLift] -= 15;
		motor[LTLift] -= 15;
	}
	else if(rPoten() > lPoten() && state == 1)
	{
		motor[RBLift] -= 15;
		motor[RTLift] -= 15;
	}
	else if(lPoten() < rPoten() && state == -1)
	{
		motor[LBLift] += 15;
		motor[LTLift] += 15;
	}
	else if(rPoten() < lPoten() && state == -1)
	{
		motor[RBLift] += 15;
		motor[RTLift] += 15;
	}

	//"Lock" Adjustment
	if(vexRT[Btn8L] == 1)
	{
		slowActivate = !slowActivate;
		wait1Msec(50);
	}
}

/////CUBE_INTAKE/////
void cubeIntake(int state)
{
	motor[RRoller] = state * 127;
	motor[LRoller] = state * 127;
}

/////SKYRISE_INTAKE/////
void skyriseIntake(bool state)
{
	if(state == 1)
	{
		SensorValue[Skyrise] = abs(SensorValue[Skyrise] - 1);
		wait1Msec(200);
	}
}
/////DUMP/////
void dumpIntake(bool state)
{
	if(state == 1 && triggered == false)
	{
		triggered = true;
		SensorValue[Dump] = 1;
	}
	if(state == 0)
	{
		triggered = false;
		SensorValue[Dump] = 0;
	}
}

/////DRIVE/////
void drive(int leftSpeed , int rightSpeed)
{
	if(leftSpeed > 0)
	{
		motor[LFBase] = TrueSpeed[leftSpeed];
		motor[LBBase] = TrueSpeed[leftSpeed];
	}
	else if(leftSpeed < 0)
	{
		motor[LFBase] = -TrueSpeed[-leftSpeed];
		motor[LBBase] = -TrueSpeed[-leftSpeed];
	}
	if(rightSpeed > 0)
	{
		motor[RFBase] = TrueSpeed[rightSpeed];
		motor[RBBase] = TrueSpeed[rightSpeed];
	}
	else if(rightSpeed < 0)
	{
		motor[RFBase] = -TrueSpeed[-rightSpeed];
		motor[RBBase] = -TrueSpeed[-rightSpeed];
	}
}

/////GYROTURN/////
void gyroTurn(int degrees)
{
	int originalHeading = SensorValue[Gyro];
	if(degrees > 0)
	{
		while(SensorValue[Gyro] < originalHeading + degrees)
		{
			drive(slowSpeed, -slowSpeed);
		}
		drive(0, 0);
	}
	else if(degrees < 0)
	{
		while(SensorValue[Gyro] > originalHeading + degrees)
		{
			drive(-slowSpeed, slowSpeed);
		}
		drive(0, 0);
	}
}

int avgPot()
{
	return round((lPoten() + rPoten()) / 2);
}

int avgEnc()
{
return round((nMotorEncoder[LFBase] + -(nMotorEncoder[RFBase])) / 2);
resetMotorEncoder(RFBase);
resetMotorEncoder(LFBase);
}
task main()
{
	resetMotorEncoder(LFBase);
	resetMotorEncoder(RFBase);

	while(true)
	{
		if(vexRT[Btn8U] == 1)
		{SensorValue[Skyrise] = 1;
			wait1Msec(100);
			cubeIntake(-1);
			wait1Msec(150);
			cubeIntake(0);
			SensorValue[Skyrise] = 0;
			motor[RFBase] = -80;
			motor[LFBase] = -80;
			motor[RBBase] = -80;
			motor[LBBase] = -80;
			wait1Msec(100);
			motor[RFBase] = 0;
			motor[LFBase] = 0;
			motor[RBBase] = 0;
			motor[LBBase] = 0;
			/*lift(1);
			while(rPoten() < 1)
			{
			}
			lift(0);*/

			motor[RFBase] = 80;
			motor[LFBase] = 80;
			motor[RBBase] = 80;
			motor[LBBase] = 80;
			wait1Msec(500);
			motor[RFBase] = 0;
			motor[LFBase] = 0;
			motor[RBBase] = 0;
			motor[LBBase] = 0;
			SensorValue[Skyrise] = 1;
			wait1Msec(200);
			
			
			
		
		}
	}
}
