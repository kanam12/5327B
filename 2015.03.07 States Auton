#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    RPot,           sensorPotentiometer)
#pragma config(Sensor, in2,    LPot,           sensorPotentiometer)
#pragma config(Sensor, in3,    Gyro,           sensorGyro)
#pragma config(Sensor, in4,    RLine,          sensorLineFollower)
#pragma config(Sensor, in5,    LLine,          sensorLineFollower)
#pragma config(Sensor, dgtl2,  Skyrise,        sensorDigitalOut)
#pragma config(Sensor, dgtl3,  Dump,           sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           RRoller,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           RBLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RTLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LBLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LTLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RBBase,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RFBase,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port8,           LBBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LFBase,        tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          LRoller,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "LOCAL_Lib.h"

#define R_JOY vexRT[Ch2]
#define L_JOY vexRT[Ch3]
#define LIFT_UP vexRT[Btn6U]
#define LIFT_DOWN vexRT[Btn5U]
#define CUBE_INTAKE vexRT[Btn6D]
#define CUBE_OUTTAKE vexRT[Btn5D]
#define SKYRISE_INTAKE vexRT[Btn8R]
#define DUMP_INTAKE vexRT[Btn7L]


/////////////////////////////////////////////////////////////////////////////////////////............................PRE_AUTON
//                          Pre-Autonomous Functions
void pre_auton()
{
	//bStopTasksBetweenModes = true;
	SensorValue[Skyrise] = 0;
	resetMotorEncoder(LFBase);
	resetMotorEncoder(RFBase);
	SensorType[in3] = sensorNone;
	wait1Msec(1000);
	SensorType[in3] = sensorGyro;
	wait1Msec(2000);
}
//
/////////////////////////////////////////////////////////////////////////////////////////

const int slowSpeed = 60;

const unsigned int TrueSpeed[128] =
{
	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	0, 21, 21, 21, 22, 22, 22, 23, 24, 24,
	25, 25, 25, 25, 26, 27, 27, 28, 28, 28,
	28, 29, 30, 30, 30, 31, 31, 32, 32, 32,
	33, 33, 34, 34, 35, 35, 35, 36, 36, 37,
	37, 37, 37, 38, 38, 39, 39, 39, 40, 40,
	41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
	46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
	52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
	61, 62, 63, 64, 65, 66, 67, 67, 68, 70,
	71, 72, 72, 73, 74, 76, 77, 78, 79, 79,
	80, 81, 83, 84, 84, 86, 86, 87, 87, 88,
	88, 89, 89, 90, 90,127,127,127
};
int rpot()
{
	int const adjVal = 0;
	return SensorValue[RPot] + adjVal;
}

int lpot()
{
	int const adjVal = 0;
	return SensorValue[LPot] + adjVal;
}

//////LIFT/////..................................................................................................TOP_Functions

void lift(int state)
{

	if(state < 0)
	{
		motorS[LBLift] = slowSpeed;
		motorS[LTLift] = slowSpeed;
		motorS[RBLift] = slowSpeed;
		motorS[RTLift] = slowSpeed;
	}
	else if (state > 0)
	{
		motorS[LBLift] = 127;
		motorS[LTLift] = 127;
		motorS[RBLift] = 127;
		motorS[RTLift] = 127;
	}
	else
	{
		motorS[LBLift] = 0;
		motorS[LTLift] = 0;
		motorS[RBLift] = 0;
		motorS[RTLift] = 0;
	}
	if(lpot() > rpot() && state == 1)
	{
		motorS[LBLift] -= 10;
		motorS[LTLift] -= 10;
	}
	else if(rpot() > lpot() && state == 1)
	{
		motorS[RBLift] -= 10;
		motorS[RTLift] -= 10;
	}
	else if(lpot() < rpot() && state == -1)
	{
		motorS[LBLift] += 10;
		motorS[LTLift] += 10;
	}
	else if(rpot() < lpot() && state == -1)
	{
		motorS[RBLift] += 10;
		motorS[RTLift] += 10;
	}
}


/////CUBE_INTAKE/////
void cubeIntake(int state)
{
	motorS[RRoller] = state * 127;
	motorS[LRoller] = state * 127;
}

/////SKYRISE_INTAKE/////
void skyriseIntake(bool state)
{
	if(state == 1)
	{
		SensorValue[Skyrise] = abs(SensorValue[Skyrise] - 1);
		wait1Msec(50);
	}
}
bool triggered = false;
/////DUMP/////
void dumpIntake(bool state)
{
	if(state == 1 && triggered == false)
	{
		triggered = true;
		SensorValue[Dump] = 1;
	}
	if(state == 0)
	{
		triggered = false;
		SensorValue[Dump] = 0;
	}
}

int potVal()
{
	int const RAdj = 0;
	int const LAdj = 0;
	return ((SensorValue[RPot] - RAdj) + (SensorValue[LPot] - LAdj))/2;
}

/////DRIVE/////
void drive(int leftSpeed , int rightSpeed)
{
	if(leftSpeed > 0)
	{
		motorS[LFBase] = TrueSpeed[leftSpeed];
		motorS[LBBase] = TrueSpeed[leftSpeed];
	}
	else if(leftSpeed < 0)
	{
		motorS[LFBase] = -TrueSpeed[-leftSpeed];
		motorS[LBBase] = -TrueSpeed[-leftSpeed];
	}
	if(rightSpeed > 0)
	{
		motorS[RFBase] = TrueSpeed[rightSpeed];
		motorS[RBBase] = TrueSpeed[rightSpeed];
	}
	else if(rightSpeed < 0)
	{
		motorS[RFBase] = -TrueSpeed[-rightSpeed];
		motorS[RBBase] = -TrueSpeed[-rightSpeed];
	}
}

/////GYROTURN/////
void gyroTurn(int degrees)
{
	int originalHeading = SensorValue[Gyro];
	if(degrees > 0)
	{
		while(SensorValue[Gyro] < originalHeading + degrees)
		{
			drive(slowSpeed, -slowSpeed);
		}
		drive(0, 0);
	}
	else if(degrees < 0)
	{
		while(SensorValue[Gyro] > originalHeading + degrees)
		{
			drive(-slowSpeed, slowSpeed);
		}
		drive(0, 0);
	}
}

/////LINE/////


/////DISTANCE/////
//NOT FUNCTIONAL SINCE ULTRASONIC HAS BEEN REMOVED
/*void sonic(int targetDistance)
{
int sonar_value = SensorValue[Distance];
while(abs(sonar_value - targetDistance) > 1)
{
motorS[LBLift] = slowSpeed * sgn(targetDistance - sonar_value);
motorS[RBLift] = slowSpeed * sgn(targetDistance - sonar_value);
motorS[LTLift] = slowSpeed * sgn(targetDistance - sonar_value);
motorS[RTLift] = slowSpeed * sgn(targetDistance - sonar_value);
}
}*/

//..........................................................................................................BOTTOM_Functions

/////////////////////////////////////////////////////////////////////////////////////////................................AUTON
//                                 Autonomous Task

task main()
{
	//Initializing stuff
	SensorValue[Skyrise] = 1;
	resetMotorEncoder(LFBase);
	resetMotorEncoder(RFBase);
	pre_auton();

	//Nudge cube onto skyrise base
	gyroTurn(30);

	//Return to original position
	gyroTurn(-30);

	//Back up 6 inches
	drive(-60, -60);
	while((nMotorEncoder[LFBase] + nMotorEncoder[RFBase]) / 2 > -500)
	{
	}
	drive(0, 0);

	//Lift reset
	lift(1);
	while(potVal() < 100)
	lift(0);
	//Outtake preload
	cubeIntake(-1);
	wait1Msec(250);
	cubeIntake(0);
	//Turn
	gyroTurn(-45);
}
